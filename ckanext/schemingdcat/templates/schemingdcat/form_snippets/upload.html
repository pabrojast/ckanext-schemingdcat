{% import 'macros/form.html' as form %}

{%- set is_upload = data.get((field.upload_field or 'upload')) -%}
{%- set is_url = data.get(field.field_name) and not is_upload -%}
{%- set upload_enabled = h.uploads_enabled() -%}
{%- set field_url = field.field_name -%}
{%- set field_upload = field.upload_field or 'upload' -%}
{%- set field_clear = field.upload_clear or 'clear_upload' -%}

<div class="schemingdcat-upload-wrapper">
  {% if is_upload and data.get('url') %}
    <div class="current-file-info alert alert-info">
      <i class="fa fa-info-circle"></i>
      <strong>{{ _('Current file:') }}</strong> 
      <span class="current-filename">{{ data.get('name', data.get('url', '')) }}</span>
      <label class="checkbox pull-right">
        <input type="checkbox" id="{{ field_clear }}" name="{{ field_clear }}" value="true">
        {{ _('Replace existing file') }}
      </label>
    </div>
  {% endif %}

  {% if upload_enabled %}
    <div class="upload-section">
      <label class="control-label">{{ _('Upload file') }}</label>
      <div class="upload-dropzone" id="dropzone-{{ field_url }}">
        <div class="dropzone-content">
          <div class="dropzone-icon">
            <i class="fa fa-cloud-upload"></i>
          </div>
          <h4>{{ _('Drag and drop a file here') }}</h4>
          <p class="drop-hint">{{ _('or') }}</p>
          <label for="{{ field_upload }}" class="btn btn-primary browse-button">
            <i class="fa fa-folder-open"></i> {{ _('Browse File') }}
          </label>
          <input type="file" 
                 id="{{ field_upload }}" 
                 name="{{ field_upload }}" 
                 class="upload-file-input"
                 style="position: absolute; left: -9999px;">
          <p class="text-muted small">
            {{ _('Supported formats: CSV, XLS, JSON, XML, PDF, and more') }}
          </p>
        </div>

        <div class="file-preview" style="display: none;">
          <div class="file-info">
            <i class="fa fa-file-o fa-2x file-icon"></i>
            <div class="file-details">
              <p class="file-name"></p>
              <p class="file-size text-muted"></p>
            </div>
            <button type="button" class="btn btn-sm btn-danger remove-file" title="{{ _('Remove file and cancel upload') }}">
              <i class="fa fa-trash"></i> {{ _('Remove') }}
            </button>
          </div>
          <div class="upload-progress">
            <div class="progress-bar">
              <div class="progress-fill"></div>
            </div>
            <p class="progress-text">{{ _('Processing...') }}</p>
          </div>
        </div>
      </div>
    </div>

    <div class="url-or-separator">
      <span>{{ _('OR') }}</span>
    </div>
  {% endif %}

  <div class="url-section">
    <label class="control-label" for="{{ field_url }}">
      {{ _('Link to a file') }}
    </label>
    <input type="text" 
           id="{{ field_url }}" 
           name="{{ field_url }}" 
           value="{{ data.get(field_url, '') }}"
           placeholder="{{ field.form_placeholder or _('https://example.com/data.csv') }}"
           class="form-control">
  </div>

  {%- snippet 'scheming/form_snippets/help_text.html', field=field -%}
</div>

<script>
(function() {
  // Cache for CSV data
  var mimeTypeCache = null;
  var csvDataPromise = null;
  var charsetCache = null;
  var charsetDataPromise = null;
  
  // Function to load CSV data and create extension to MIME type mapping
  function loadMimeTypeData() {
    if (csvDataPromise) {
      return csvDataPromise;
    }
    
    csvDataPromise = new Promise(function(resolve, reject) {
      if (mimeTypeCache) {
        resolve(mimeTypeCache);
        return;
      }
      
      var xhr = new XMLHttpRequest();
      xhr.open('GET', '/static/application.csv', true);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            try {
              var csvData = xhr.responseText;
              var mapping = {};
              var lines = csvData.split('\n');
              
              // Skip header line
              for (var i = 1; i < lines.length; i++) {
                var line = lines[i].trim();
                if (!line) continue;
                
                var parts = line.split(',');
                if (parts.length >= 2) {
                  var name = parts[0].trim().toLowerCase();
                  var template = parts[1].trim();
                  
                  // Map common file extensions to MIME types
                  mapping[name] = template;
                  
                  // Add additional mappings for common extensions
                  if (name === 'json') {
                    mapping['geojson'] = 'application/geo+json';
                  } else if (name === 'msword') {
                    mapping['doc'] = template;
                  } else if (name === 'vnd.ms-excel') {
                    mapping['xls'] = template;
                    mapping['xlsx'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
                  } else if (name === 'vnd.ms-powerpoint') {
                    mapping['ppt'] = template;
                    mapping['pptx'] = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';
                  } else if (name === 'xml') {
                    mapping['rdf'] = 'application/rdf+xml';
                    mapping['kml'] = 'application/vnd.google-earth.kml+xml';
                    mapping['gml'] = 'application/gml+xml';
                    mapping['sld'] = 'application/vnd.ogc.sld+xml';
                  } else if (name === 'zip') {
                    mapping['kmz'] = 'application/vnd.google-earth.kmz';
                    mapping['gpkg'] = 'application/geopackage+sqlite3';
                  }
                }
              }
              
              // Add common MIME types not in the CSV
              mapping['csv'] = 'text/csv';
              mapping['txt'] = 'text/plain';
              mapping['docx'] = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
              mapping['pptx'] = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';
              mapping['tar'] = 'application/x-tar';
              mapping['gz'] = 'application/gzip';
              mapping['mp4'] = 'video/mp4';
              mapping['avi'] = 'video/x-msvideo';
              mapping['mov'] = 'video/quicktime';
              mapping['shp'] = 'application/x-esri-shape';
              
              mimeTypeCache = mapping;
              resolve(mapping);
            } catch (e) {
              reject(e);
            }
          } else {
            reject(new Error('Failed to load CSV data'));
          }
        }
      };
      xhr.send();
    });
    
    return csvDataPromise;
  }
  
  // Function to load character sets CSV data
  function loadCharsetData() {
    if (charsetDataPromise) {
      return charsetDataPromise;
    }
    
    charsetDataPromise = new Promise(function(resolve, reject) {
      if (charsetCache) {
        resolve(charsetCache);
        return;
      }
      
      var xhr = new XMLHttpRequest();
      xhr.open('GET', '/static/character-sets-1.csv', true);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            try {
              var csvData = xhr.responseText;
              var mapping = {};
              
              // The CSV format is complex with line breaks inside cells
              // We'll use a simpler approach with known mappings for common file types
              var lines = csvData.split('\n');
              
              for (var i = 1; i < lines.length; i++) {
                var line = lines[i].trim();
                if (!line || line.startsWith(',')) continue;
                
                // Try to extract the preferred MIME name (first column)
                var commaIndex = line.indexOf(',');
                if (commaIndex > 0) {
                  var mimeName = line.substring(0, commaIndex).trim();
                  if (mimeName) {
                    mapping[mimeName.toLowerCase()] = mimeName;
                  }
                }
              }
              
              // Add common charset mappings for file types
              mapping['utf-8'] = 'UTF-8';
              mapping['utf8'] = 'UTF-8';
              mapping['iso-8859-1'] = 'ISO-8859-1';
              mapping['latin1'] = 'ISO-8859-1';
              mapping['windows-1252'] = 'windows-1252';
              mapping['ascii'] = 'US-ASCII';
              mapping['us-ascii'] = 'US-ASCII';
              
              charsetCache = mapping;
              resolve(mapping);
            } catch (e) {
              reject(e);
            }
          } else {
            reject(new Error('Failed to load charset data'));
          }
        }
      };
      xhr.send();
    });
    
    return charsetDataPromise;
  }
  
  // Function to get character encoding for a file extension or format
  function getCharsetForFormat(extension, format, callback) {
    // Default charset mappings based on file type
    var defaultCharsets = {
      'csv': 'UTF-8',
      'json': 'UTF-8',
      'geojson': 'UTF-8',
      'xml': 'UTF-8',
      'rdf': 'UTF-8',
      'txt': 'UTF-8',
      'kml': 'UTF-8',
      'gml': 'UTF-8',
      'sld': 'UTF-8',
      'html': 'UTF-8',
      'htm': 'UTF-8',
      'js': 'UTF-8',
      'css': 'UTF-8'
    };
    
    var ext = extension ? extension.toLowerCase() : '';
    var fmt = format ? format.toLowerCase() : '';
    
    // First try to get from extension, then from format
    var defaultCharset = defaultCharsets[ext] || defaultCharsets[fmt] || 'UTF-8';
    
    loadCharsetData().then(function(mapping) {
      // For text-based formats, default to UTF-8
      callback(defaultCharset);
    }).catch(function(error) {
      console.warn('Failed to load charset data:', error);
      // Use default charset
      callback(defaultCharset);
    });
  }
  
  // Function to get MIME type for a file extension
  function getMimeTypeForExtension(extension, callback) {
    // Fallback MIME types for common extensions
    var fallbackMimeTypes = {
      'csv': 'text/csv',
      'json': 'application/json',
      'geojson': 'application/geo+json',
      'xml': 'application/xml',
      'rdf': 'application/rdf+xml',
      'pdf': 'application/pdf',
      'doc': 'application/msword',
      'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'ppt': 'application/vnd.ms-powerpoint',
      'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      'xls': 'application/vnd.ms-excel',
      'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'txt': 'text/plain',
      'zip': 'application/zip',
      'tar': 'application/x-tar',
      'gz': 'application/gzip',
      'mp4': 'video/mp4',
      'avi': 'video/x-msvideo',
      'mov': 'video/quicktime',
      'shp': 'application/x-esri-shape',
      'kml': 'application/vnd.google-earth.kml+xml',
      'kmz': 'application/vnd.google-earth.kmz',
      'gml': 'application/gml+xml',
      'gpkg': 'application/geopackage+sqlite3',
      'sld': 'application/vnd.ogc.sld+xml'
    };
    
    loadMimeTypeData().then(function(mapping) {
      var ext = extension.toLowerCase();
      var mimeType = mapping[ext] || fallbackMimeTypes[ext];
      callback(mimeType);
    }).catch(function(error) {
      console.warn('Failed to load MIME type data:', error);
      // Use fallback MIME types
      var ext = extension.toLowerCase();
      var mimeType = fallbackMimeTypes[ext];
      callback(mimeType);
    });
  }

  // Wait for DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initUpload);
  } else {
    initUpload();
  }

  function initUpload() {
    var wrapper = document.querySelector('.schemingdcat-upload-wrapper');
    if (!wrapper) return;

    var fileInput = wrapper.querySelector('.upload-file-input');
    var dropzone = wrapper.querySelector('.upload-dropzone');
    var dropzoneContent = wrapper.querySelector('.dropzone-content');
    var filePreview = wrapper.querySelector('.file-preview');
    var removeButton = wrapper.querySelector('.remove-file');
    var previewSyncTimer = null; // to cancel intervals
    
    if (!fileInput || !dropzone) return;
    
    // Setup format field listener for spatial processing
    setupFormatFieldListener();
    
    // Auto-fill date field if exists and is empty
    // Look for resource date fields specifically
    var dateFields = document.querySelectorAll('input[type="date"]');
    dateFields.forEach(function(field) {
      if ((field.name.indexOf('created') !== -1 || field.name.indexOf('__0__created') !== -1) && !field.value) {
        var today = new Date();
        var yyyy = today.getFullYear();
        var mm = today.getMonth() + 1;
        var dd = today.getDate();
        
        if (dd < 10) dd = '0' + dd;
        if (mm < 10) mm = '0' + mm;
        
        field.value = yyyy + '-' + mm + '-' + dd;
      }
    });

    // Function to auto-fill name field with filename (similar to CloudStorage functionality)
    function autoFillNameField(fileName, forceUpdate) {
      // Extract name without extension
      var nameWithoutExtension = fileName.replace(/\.[^/.]+$/, '');
      
      // Clean name: replace underscores and hyphens with spaces, normalize whitespace
      var cleanName = nameWithoutExtension.replace(/[_-]/g, ' ').replace(/\s+/g, ' ').trim();
      
      // Find form fields to populate
      var form = wrapper.closest('form');
      if (form) {
        // Priority order for name field detection
        var nameSelectors = [
          'input[name="name"]',
          'input[name="title"]', 
          '#field-name',
          '#field-title',
          'input[id*="name"]',
          'input[id*="title"]',
          'input[name*="name"]',
          'input[name*="title"]'
        ];
        
        var nameField = null;
        for (var i = 0; i < nameSelectors.length; i++) {
          nameField = form.querySelector(nameSelectors[i]);
          if (nameField) break;
        }
        
        // Update field if it's empty OR if we're forcing an update (new file upload)
        if (nameField && (!nameField.value.trim() || forceUpdate)) {
          nameField.value = cleanName;
          nameField.setAttribute('data-auto-filled', 'true'); // Mark as auto-filled
          nameField.dispatchEvent(new Event('change', { bubbles: true }));
          nameField.dispatchEvent(new Event('input', { bubbles: true }));
          
          // Add visual feedback
          nameField.style.backgroundColor = '#d4edda';
          setTimeout(function() {
            nameField.style.backgroundColor = '';
          }, 2000);
          
          console.log('[schemingdcat-upload] Auto-populated name field:', cleanName);
        }
      }
    }

    // Function to clear auto-filled fields when removing a file
    function clearAutoFilledFields() {
      var form = wrapper.closest('form');
      if (form) {
        // Clear name field if it was auto-filled
        var nameSelectors = [
          'input[name="name"]',
          'input[name="title"]', 
          '#field-name',
          '#field-title',
          'input[id*="name"]',
          'input[id*="title"]',
          'input[name*="name"]',
          'input[name*="title"]'
        ];
        
        var nameField = null;
        for (var i = 0; i < nameSelectors.length; i++) {
          nameField = form.querySelector(nameSelectors[i]);
          if (nameField) break;
        }
        
        if (nameField && nameField.hasAttribute('data-auto-filled')) {
          nameField.value = '';
          nameField.removeAttribute('data-auto-filled');
          nameField.dispatchEvent(new Event('change', { bubbles: true }));
          nameField.dispatchEvent(new Event('input', { bubbles: true }));
        }
        
        // Clear format field if it was auto-filled
        var formatFields = document.querySelectorAll('input[name*="format"]');
        formatFields.forEach(function(field) {
          if ((field.name.indexOf('resources') !== -1 || field.name === 'format') && 
              field.hasAttribute('data-auto-filled')) {
            field.value = '';
            field.removeAttribute('data-auto-filled');
            field.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        
        // Clear mimetype field if it was auto-filled
        var mimetypeFields = document.querySelectorAll('input[name*="mimetype"]');
        mimetypeFields.forEach(function(field) {
          if ((field.name.indexOf('resources') !== -1 || field.name === 'mimetype') && 
              field.hasAttribute('data-auto-filled')) {
            field.value = '';
            field.removeAttribute('data-auto-filled');
            field.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        
        // Clear encoding field if it was auto-filled
        var encodingFields = document.querySelectorAll('input[name*="encoding"]');
        encodingFields.forEach(function(field) {
          if ((field.name.indexOf('resources') !== -1 || field.name === 'encoding') && 
              field.hasAttribute('data-auto-filled')) {
            field.value = '';
            field.removeAttribute('data-auto-filled');
            field.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        
        console.log('[schemingdcat-upload] Cleared auto-filled fields');
      }
    }

    // File input change
    fileInput.addEventListener('change', function(e) {
      var files = e.target.files;
      if (files && files.length > 0) {
        // Clear any previous file/upload before showing the new one
        if (filePreview.style.display !== 'none') {
          clearFile();
          // Small pause for user to see the transition
          setTimeout(function() {
            processNewFile(files[0]);
          }, 100);
        } else {
          processNewFile(files[0]);
        }
      }
    });
    
    function processNewFile(file) {
      displayFile(file);
      
      var fileName = file.name;
      var ext = fileName.split('.').pop().toLowerCase();
      
      // Auto-fill name field (force update to overwrite previous values)
      autoFillNameField(fileName, true);
      
      // Auto-fill format field if exists
      var formatFields = document.querySelectorAll('input[name*="format"]');
      var formatField = null;
      formatFields.forEach(function(field) {
        if (field.name.indexOf('resources') !== -1 || field.name === 'format') {
          formatField = field;
        }
      });
      
      if (formatField) {
        var extUpper = ext.toUpperCase();
        
        // Format mapping
        var formatMap = {
          'CSV': 'CSV',
          'XLS': 'XLS', 
          'XLSX': 'XLS',
          'JSON': 'JSON',
          'GEOJSON': 'GeoJSON',
          'XML': 'XML',
          'RDF': 'RDF',
          'PDF': 'PDF',
          'DOC': 'DOC',
          'DOCX': 'DOC',
          'PPT': 'PPT',
          'PPTX': 'PPT',
          'TXT': 'TXT',
          'ZIP': 'ZIP',
          'TAR': 'TAR',
          'GZ': 'GZ',
          'MP4': 'MP4',
          'AVI': 'AVI',
          'MOV': 'MOV',
          'SHP': 'SHP',
          'KML': 'KML',
          'KMZ': 'KMZ',
          'GML': 'GML',
          'GPKG': 'GPKG',
          'SLD': 'SLD'
        };
        
        formatField.value = formatMap[extUpper] || extUpper;
        formatField.setAttribute('data-auto-filled', 'true'); // Mark as auto-filled
        // Trigger change event
        var event = new Event('change', { bubbles: true });
        formatField.dispatchEvent(event);
      }
      
      // Auto-fill mimetype field if exists
      var mimetypeFields = document.querySelectorAll('input[name*="mimetype"]');
      var mimetypeField = null;
      mimetypeFields.forEach(function(field) {
        if (field.name.indexOf('resources') !== -1 || field.name === 'mimetype') {
          mimetypeField = field;
        }
      });
      
      if (mimetypeField) {
        getMimeTypeForExtension(ext, function(mimeType) {
          if (mimeType) {
            mimetypeField.value = mimeType;
            mimetypeField.setAttribute('data-auto-filled', 'true'); // Mark as auto-filled
            // Trigger change event
            var event = new Event('change', { bubbles: true });
            mimetypeField.dispatchEvent(event);
          }
        });
      }
      
      // Auto-fill encoding field if exists
      var encodingFields = document.querySelectorAll('input[name*="encoding"]');
      var encodingField = null;
      encodingFields.forEach(function(field) {
        if (field.name.indexOf('resources') !== -1 || field.name === 'encoding') {
          encodingField = field;
        }
      });
      
      if (encodingField) {
        var currentFormat = formatField ? formatField.value : '';
        getCharsetForFormat(ext, currentFormat, function(charset) {
          if (charset) {
            encodingField.value = charset;
            encodingField.setAttribute('data-auto-filled', 'true'); // Mark as auto-filled
            // Trigger change event
            var event = new Event('change', { bubbles: true });
            encodingField.dispatchEvent(event);
          }
        });
      }

      // Extract spatial extent from geospatial files
      extractSpatialExtentFromFile(file, ext);
      
      // Set up format field change listener for spatial processing
      if (formatField) {
        setupSpatialProcessingOnFormatChange(formatField);
      }
    }

    // Remove file button
    if (removeButton) {
      removeButton.addEventListener('click', function(e) {
        e.preventDefault();
        clearFile();
      });
    }

    // Drag and drop
    dropzone.addEventListener('dragover', function(e) {
      e.preventDefault();
      e.stopPropagation();
      dropzone.classList.add('dragover');
    });

    dropzone.addEventListener('dragleave', function(e) {
      e.preventDefault();
      e.stopPropagation();
      dropzone.classList.remove('dragover');
    });

    dropzone.addEventListener('drop', function(e) {
      e.preventDefault();
      e.stopPropagation();
      dropzone.classList.remove('dragover');
      
      var files = e.dataTransfer.files;
      if (files && files.length > 0) {
        fileInput.files = files;
        
        // Clear any previous file/upload before showing the new one
        if (filePreview.style.display !== 'none') {
          clearFile();
          // Small pause for user to see the transition
          setTimeout(function() {
            processNewFile(files[0]);
            // Trigger change event for other modules
            var event = new Event('change', { bubbles: true });
            fileInput.dispatchEvent(event);
          }, 100);
        } else {
          processNewFile(files[0]);
          // Trigger change event for other modules
          var event = new Event('change', { bubbles: true });
          fileInput.dispatchEvent(event);
        }
      }
    });

    dropzone.addEventListener('click', function(e) {
      // Avoid opening dialog if click comes from specific buttons or preview area
      var isBrowseBtn = e.target.closest('.browse-button');
      var isRemoveBtn = e.target.closest('.remove-file');
      var isPreviewArea = filePreview.contains(e.target);
      if (!isBrowseBtn && !isRemoveBtn && !isPreviewArea) {
        // Open file selector
        fileInput.click();
      }
    });
    
    // URL input change for format detection
    var urlInput = wrapper.querySelector('input[name="{{ field_url }}"]');
    if (urlInput) {
      urlInput.addEventListener('blur', function(e) {
        var url = e.target.value;
        if (url) {
          // Extract filename from URL for auto-fill name field
          var urlPath = url.split('?')[0].split('#')[0]; // Remove query params and fragments
          var fileName = urlPath.split('/').pop(); // Get last part of path
          if (fileName) {
            autoFillNameField(fileName);
          }
          
          // Extract extension from URL
          var urlParts = url.split('?')[0].split('.');
          if (urlParts.length > 1) {
            var ext = urlParts[urlParts.length - 1].toLowerCase();
            var extUpper = ext.toUpperCase();
            
            // Auto-fill format field
            var formatFields = document.querySelectorAll('input[name*="format"]');
            var formatField = null;
            formatFields.forEach(function(field) {
              if (field.name.indexOf('resources') !== -1 || field.name === 'format') {
                formatField = field;
              }
            });
            
            if (formatField && !formatField.value) {
              // Format mapping
              var formatMap = {
                'CSV': 'CSV',
                'XLS': 'XLS', 
                'XLSX': 'XLS',
                'JSON': 'JSON',
                'GEOJSON': 'GeoJSON',
                'XML': 'XML',
                'RDF': 'RDF',
                'PDF': 'PDF',
                'DOC': 'DOC',
                'DOCX': 'DOC',
                'PPT': 'PPT',
                'PPTX': 'PPT',
                'TXT': 'TXT',
                'ZIP': 'ZIP',
                'TAR': 'TAR',
                'GZ': 'GZ',
                'MP4': 'MP4',
                'AVI': 'AVI',
                'MOV': 'MOV',
                'SHP': 'SHP',
                'KML': 'KML',
                'KMZ': 'KMZ',
                'GML': 'GML',
                'GPKG': 'GPKG',
                'SLD': 'SLD'
              };
              
              formatField.value = formatMap[extUpper] || extUpper;
              // Trigger change event
              var event = new Event('change', { bubbles: true });
              formatField.dispatchEvent(event);
            }
            
            // Auto-fill mimetype field
            var mimetypeFields = document.querySelectorAll('input[name*="mimetype"]');
            var mimetypeField = null;
            mimetypeFields.forEach(function(field) {
              if (field.name.indexOf('resources') !== -1 || field.name === 'mimetype') {
                mimetypeField = field;
              }
            });
            
            if (mimetypeField && !mimetypeField.value) {
              getMimeTypeForExtension(ext, function(mimeType) {
                if (mimeType) {
                  mimetypeField.value = mimeType;
                  // Trigger change event
                  var event = new Event('change', { bubbles: true });
                  mimetypeField.dispatchEvent(event);
                }
              });
            }
            
            // Auto-fill encoding field
            var encodingFields = document.querySelectorAll('input[name*="encoding"]');
            var encodingField = null;
            encodingFields.forEach(function(field) {
              if (field.name.indexOf('resources') !== -1 || field.name === 'encoding') {
                encodingField = field;
              }
            });
            
            if (encodingField && !encodingField.value) {
              var currentFormat = formatField ? formatField.value : '';
              getCharsetForFormat(ext, currentFormat, function(charset) {
                if (charset) {
                  encodingField.value = charset;
                  // Trigger change event
                  var event = new Event('change', { bubbles: true });
                  encodingField.dispatchEvent(event);
                }
              });
            }
          }
        }
      });
    }

    function displayFile(file) {
      var fileName = filePreview.querySelector('.file-name');
      var fileSize = filePreview.querySelector('.file-size');
      var fileIcon = filePreview.querySelector('.file-icon');
      var progressBar = filePreview.querySelector('.upload-progress');
      var progressText = filePreview.querySelector('.progress-text');
      
      fileName.textContent = file.name;
      fileSize.textContent = formatFileSize(file.size);
      
      // Update icon
      var ext = file.name.split('.').pop().toLowerCase();
      var iconClass = getFileIcon(ext);
      fileIcon.className = 'fa fa-2x file-icon ' + iconClass;
      
      // Show preview, hide dropzone content
      dropzoneContent.style.display = 'none';
      filePreview.style.display = 'block';
      
      // Show progress animation and mark as completed when initial animation finishes
      if (progressBar) {
        progressBar.style.display = 'block';
        var progressFill = progressBar.querySelector('.progress-fill');
        // After 2s (end of CSS animation), set bar to 100% and change text
        setTimeout(function() {
          if (progressFill) {
            progressFill.style.animation = 'none';
            progressFill.style.width = '100%';
          }
          if (progressText) {
            progressText.textContent = 'Done';
          }
        }, 2000);
      }
      
      // Check clear checkbox if exists
      var clearCheckbox = wrapper.querySelector('input[type="checkbox"][id*="clear"]');
      if (clearCheckbox) {
        clearCheckbox.checked = true;
      }

      // Synchronize with CloudStorage (if available) to show real progress
      setTimeout(function() {
        var csContainer = wrapper.querySelector('.cloudstorage-progress-container');
        if (!csContainer) return; // no CloudStorage
        var csBar = csContainer.querySelector('.progress-bar');
        var csStatus = csContainer.querySelector('.cloudstorage-progress-status');
        if (!csBar) return;
        previewSyncTimer = setInterval(function() {
          // Copy bar width
          var width = csBar.style.width;
          if (width) {
            if (progressFill) progressFill.style.width = width;
          }
          // Copy status text
          if (csStatus && csStatus.textContent) {
            progressText.textContent = csStatus.textContent;
          }
          // Complete
          if (width && width.indexOf('100%') !== -1) {
            if (progressText) progressText.textContent = 'Done';
            clearInterval(previewSyncTimer);
            previewSyncTimer = null;
          }
        }, 300);
      }, 300);
    }

    function clearFile() {
      fileInput.value = '';
      dropzoneContent.style.display = 'block';
      filePreview.style.display = 'none';
      
      // Clear auto-filled form fields
      clearAutoFilledFields();
      
      // stop synchronization if active
      if (previewSyncTimer) {
        clearInterval(previewSyncTimer);
        previewSyncTimer = null;
      }
      // Reset internal progress
      var progressFill = filePreview.querySelector('.progress-fill');
      if (progressFill) {
        progressFill.style.width = '0%';
        progressFill.style.animation = 'progressAnimation 2s ease-in-out infinite, shimmer 1.5s linear infinite';
      }
      var progressText = filePreview.querySelector('.progress-text');
      if (progressText) {
        progressText.textContent = 'Processing...';
      }
      
      // Uncheck clear checkbox if exists
      var clearCheckbox = wrapper.querySelector('input[type="checkbox"][id*="clear"]');
      if (clearCheckbox) {
        clearCheckbox.checked = false;
      }
      
      // Cancel/hide CloudStorage if active and delete file from cloud storage
      var cloudStorageContainers = document.querySelectorAll('.cloudstorage-progress-container');
      cloudStorageContainers.forEach(function(container) {
        // Hide CloudStorage progress container
        container.style.display = 'none';
        
        // Get upload information to delete the file
        var uploadId = container.getAttribute('data-upload-id');
        var fileName = container.getAttribute('data-file-name');
        var resourceId = container.getAttribute('data-resource-id');
        
        if (uploadId && window.cloudStorageUploads && window.cloudStorageUploads[uploadId]) {
          // Mark as cancelled
          window.cloudStorageUploads[uploadId].cancelled = true;
          
          // If it's a multipart upload, try to abort it
          if (window.cloudStorageUploads[uploadId].isMultipart) {
            abortMultipartUpload(uploadId);
          }
        }
        
        // If we have file information, try to delete it from cloud storage
        if (resourceId && fileName) {
          deleteCloudStorageFile(resourceId, fileName);
        }
      });
      
      // Also clear CloudStorage indicator if it exists
      var cloudStorageIndicator = wrapper.parentElement.querySelector('.cloudstorage-indicator');
      if (cloudStorageIndicator) {
        cloudStorageIndicator.style.display = 'none';
      }
      
      // Dispatch custom event so other modules know it was cancelled
      var cancelEvent = new CustomEvent('schemingdcat:upload-cancelled', {
        detail: { wrapper: wrapper },
        bubbles: true
      });
      wrapper.dispatchEvent(cancelEvent);
      
      // Show temporary cancellation notification
      var notification = document.createElement('div');
      notification.className = 'upload-cancelled-notification';
      notification.innerHTML = '<i class="fa fa-check-circle"></i> ' + 'Upload cancelled';
      dropzone.appendChild(notification);
      
      setTimeout(function() {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 2000);
    }
    
    // Function to abort multipart upload
    function abortMultipartUpload(uploadId) {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('POST', '/api/action/cloudstorage_abort_multipart', true);
        xhr.setRequestHeader('Content-Type', 'application/json');
        
        var data = JSON.stringify({
          upload_id: uploadId
        });
        
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              console.debug('Multipart upload aborted successfully:', uploadId);
            } else {
              console.warn('Failed to abort multipart upload:', xhr.status, xhr.responseText);
            }
          }
        };
        
        xhr.send(data);
      } catch (e) {
        console.warn('Error aborting multipart upload:', e);
      }
    }
    
    // Function to delete file from cloud storage
    function deleteCloudStorageFile(resourceId, fileName) {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('POST', '/api/action/cloudstorage_delete_file', true);
        xhr.setRequestHeader('Content-Type', 'application/json');
        
        var data = JSON.stringify({
          resource_id: resourceId,
          filename: fileName
        });
        
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              console.debug('Cloud storage file deleted successfully:', fileName);
            } else {
              console.warn('Failed to delete cloud storage file:', xhr.status, xhr.responseText);
              // Try alternative method using resource_delete if file was already created as resource
              if (resourceId) {
                deleteResourceAndFile(resourceId);
              }
            }
          }
        };
        
        xhr.send(data);
      } catch (e) {
        console.warn('Error deleting cloud storage file:', e);
      }
    }
    
    // Alternative function to delete complete resource (includes file)
    function deleteResourceAndFile(resourceId) {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('POST', '/api/action/resource_delete', true);
        xhr.setRequestHeader('Content-Type', 'application/json');
        
        var data = JSON.stringify({
          id: resourceId
        });
        
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              console.debug('Resource and file deleted successfully:', resourceId);
            } else {
              console.warn('Failed to delete resource:', xhr.status, xhr.responseText);
            }
          }
        };
        
        xhr.send(data);
      } catch (e) {
        console.warn('Error deleting resource:', e);
      }
    }

    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      var k = 1024;
      var sizes = ['Bytes', 'KB', 'MB', 'GB'];
      var i = Math.floor(Math.log(bytes) / Math.log(k));
      return (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
    }

    function getFileIcon(ext) {
      var iconMap = {
        'pdf': 'fa-file-pdf-o',
        'doc': 'fa-file-word-o',
        'docx': 'fa-file-word-o',
        'ppt': 'fa-file-powerpoint-o',
        'pptx': 'fa-file-powerpoint-o',
        'xls': 'fa-file-excel-o',
        'xlsx': 'fa-file-excel-o',
        'csv': 'fa-file-text-o',
        'txt': 'fa-file-text-o',
        'json': 'fa-file-code-o',
        'geojson': 'fa-file-code-o',
        'xml': 'fa-file-code-o',
        'rdf': 'fa-file-code-o',
        'kml': 'fa-file-code-o',
        'gml': 'fa-file-code-o',
        'sld': 'fa-file-code-o',
        'zip': 'fa-file-archive-o',
        'tar': 'fa-file-archive-o',
        'gz': 'fa-file-archive-o',
        'kmz': 'fa-file-archive-o',
        'mp4': 'fa-file-video-o',
        'avi': 'fa-file-video-o',
        'mov': 'fa-file-video-o',
        'shp': 'fa-map-o',
        'gpkg': 'fa-map-o',
        'tif': 'fa-file-image-o',
        'tiff': 'fa-file-image-o',
        'jpg': 'fa-file-image-o',
        'jpeg': 'fa-file-image-o',
        'png': 'fa-file-image-o',
        'gif': 'fa-file-image-o'
      };
      return iconMap[ext] || 'fa-file-o';
    }
  }

  // Function to extract spatial extent from resource URL (post-upload processing)
  function extractSpatialExtentFromResource(resourceUrl, resourceFormat) {
    console.log('Processing resource for spatial extent:', resourceUrl, 'format:', resourceFormat);
    
    // Find the spatial_extent field in the form
    var spatialExtentField = document.querySelector('textarea[name="spatial_extent"], input[name="spatial_extent"]');
    if (!spatialExtentField) {
      console.debug('No spatial_extent field found in form');
      return;
    }

    // Show a loading indicator in the spatial extent field
    var originalPlaceholder = spatialExtentField.placeholder;
    spatialExtentField.placeholder = '{{ _("Processing uploaded file for spatial extent...") }}';
    spatialExtentField.classList.add('loading');

    // Prepare request data
    var requestData = {
      resource_url: resourceUrl,
      resource_format: resourceFormat
    };

    // Make request to extract spatial extent from resource
    fetch('/api/extract-spatial-extent-from-resource', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestData)
    })
    .then(function(response) {
      return response.json();
    })
    .then(function(data) {
      spatialExtentField.classList.remove('loading');
      spatialExtentField.placeholder = originalPlaceholder;
      
      if (data.success && data.extent) {
        // Set the extracted extent in the field
        spatialExtentField.value = JSON.stringify(data.extent, null, 2);
        
        // Trigger change event
        var event = new Event('change', { bubbles: true });
        spatialExtentField.dispatchEvent(event);
        
        // Show success message
        showSpatialExtentMessage('{{ _("Spatial extent extracted successfully from uploaded file.") }}', 'success');
        
        console.log('Spatial extent extracted from resource:', data.extent);
      } else {
        console.debug('Could not extract spatial extent from resource:', data.error || 'Unknown error');
        showSpatialExtentMessage('{{ _("Could not extract spatial extent from this resource. You can manually enter the spatial extent if needed.") }}', 'info');
      }
    })
    .catch(function(error) {
      spatialExtentField.classList.remove('loading');
      spatialExtentField.placeholder = originalPlaceholder;
      
      console.debug('Error in resource spatial extent extraction:', error);
      showSpatialExtentMessage('{{ _("Error processing uploaded file. You can manually enter the spatial extent if needed.") }}', 'warning');
    });
  }

  // Function to setup format field listener for spatial processing
  function setupFormatFieldListener() {
    // Find format fields
    var formatFields = document.querySelectorAll('input[name*="format"]');
    formatFields.forEach(function(formatField) {
      if (formatField.name.indexOf('resources') !== -1 || formatField.name === 'format') {
        formatField.addEventListener('change', function(e) {
          var format = e.target.value.toUpperCase();
          
          // If format is changed to SHP, try to process any existing URL for spatial extent
          if (format === 'SHP' || format === 'SHAPEFILE') {
            // Look for URL field
            var urlFields = document.querySelectorAll('input[name*="url"]');
            var resourceUrl = null;
            
            urlFields.forEach(function(urlField) {
              if ((urlField.name.indexOf('resources') !== -1 || urlField.name === 'url') && urlField.value) {
                resourceUrl = urlField.value;
              }
            });
            
            if (resourceUrl && resourceUrl.trim()) {
              console.log('Format changed to SHP, processing resource:', resourceUrl);
              extractSpatialExtentFromResource(resourceUrl, format);
            }
          }
        });
      }
    });
  }

  // Function to extract spatial extent from geospatial files
  function extractSpatialExtentFromFile(file, ext) {
    // Check if this is a geospatial file type
    var spatialExtensions = ['shp', 'zip', 'tif', 'tiff', 'geotiff', 'kml', 'gpkg', 'geojson', 'json'];
    
    if (!spatialExtensions.includes(ext.toLowerCase())) {
      return; // Not a spatial file, skip extraction
    }

    // Find the spatial_extent field in the form
    var spatialExtentField = document.querySelector('textarea[name="spatial_extent"], input[name="spatial_extent"]');
    if (!spatialExtentField) {
      console.debug('No spatial_extent field found in form');
      return;
    }

    // Show a loading indicator in the spatial extent field
    var originalPlaceholder = spatialExtentField.placeholder;
    spatialExtentField.placeholder = '{{ _("Extracting spatial extent from file...") }}';
    spatialExtentField.classList.add('loading');

    // Create FormData to send the file
    var formData = new FormData();
    formData.append('file', file);

    // Make request to extract spatial extent
    fetch('/api/extract-spatial-extent', {
      method: 'POST',
      body: formData
    })
    .then(function(response) {
      return response.json();
    })
    .then(function(data) {
      spatialExtentField.classList.remove('loading');
      spatialExtentField.placeholder = originalPlaceholder;
      
      if (data.success && data.extent) {
        // Set the extracted extent in the field
        spatialExtentField.value = JSON.stringify(data.extent, null, 2);
        
        // Trigger change event
        var event = new Event('change', { bubbles: true });
        spatialExtentField.dispatchEvent(event);
        
        // Show success message
        showSpatialExtentMessage('{{ _("Spatial extent extracted successfully from file.") }}', 'success');
        
        console.log('Spatial extent extracted:', data.extent);
      } else {
        console.debug('Could not extract spatial extent:', data.error || 'Unknown error');
        showSpatialExtentMessage('{{ _("Could not extract spatial extent from this file. You can manually enter the spatial extent if needed.") }}', 'info');
      }
    })
    .catch(function(error) {
      spatialExtentField.classList.remove('loading');
      spatialExtentField.placeholder = originalPlaceholder;
      
      console.debug('Error in spatial extent extraction:', error);
      showSpatialExtentMessage('{{ _("Error extracting spatial extent. You can manually enter the spatial extent if needed.") }}', 'warning');
    });
  }

  // Function to extract spatial extent from resource URL (after upload)
  function extractSpatialExtentFromResource(resourceUrl, resourceFormat) {
    // Find the spatial_extent field in the form
    var spatialExtentField = document.querySelector('textarea[name="spatial_extent"], input[name="spatial_extent"]');
    if (!spatialExtentField) {
      console.debug('No spatial_extent field found in form');
      return;
    }

    // Show a loading indicator in the spatial extent field
    var originalPlaceholder = spatialExtentField.placeholder;
    spatialExtentField.placeholder = '{{ _("Extracting spatial extent from uploaded file...") }}';
    spatialExtentField.classList.add('loading');

    // Make request to extract spatial extent from resource
    fetch('/api/extract-spatial-extent', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        resource_url: resourceUrl,
        resource_format: resourceFormat
      })
    })
    .then(function(response) {
      return response.json();
    })
    .then(function(data) {
      spatialExtentField.classList.remove('loading');
      spatialExtentField.placeholder = originalPlaceholder;
      
      if (data.success && data.extent) {
        // Set the extracted extent in the field
        spatialExtentField.value = JSON.stringify(data.extent, null, 2);
        
        // Trigger change event
        var event = new Event('change', { bubbles: true });
        spatialExtentField.dispatchEvent(event);
        
        // Show success message
        showSpatialExtentMessage('{{ _("Spatial extent extracted successfully from uploaded file.") }}', 'success');
        
        console.log('Spatial extent extracted from resource:', data.extent);
      } else {
        console.debug('Could not extract spatial extent from resource:', data.error || 'Unknown error');
        showSpatialExtentMessage('{{ _("Could not extract spatial extent from this resource. You can manually enter the spatial extent if needed.") }}', 'info');
      }
    })
    .catch(function(error) {
      spatialExtentField.classList.remove('loading');
      spatialExtentField.placeholder = originalPlaceholder;
      
      console.debug('Error in spatial extent extraction from resource:', error);
      showSpatialExtentMessage('{{ _("Error extracting spatial extent from resource. You can manually enter the spatial extent if needed.") }}', 'warning');
    });
  }

  // Function to setup spatial processing when format is changed
  function setupSpatialProcessingOnFormatChange(formatField) {
    // Remove existing listener if any
    if (formatField._spatialListener) {
      formatField.removeEventListener('change', formatField._spatialListener);
    }
    
    // Add new listener
    formatField._spatialListener = function(e) {
      var format = e.target.value;
      
      // If user changed format to SHP, try to extract spatial extent
      if (format && format.toLowerCase() === 'shp') {
        console.log('Format changed to SHP, attempting spatial extent extraction');
        
        // Look for resource URL in the form
        var resourceUrlField = document.querySelector('input[name*="url"]');
        if (resourceUrlField && resourceUrlField.value) {
          var resourceUrl = resourceUrlField.value;
          console.log('Found resource URL:', resourceUrl);
          
          // Extract spatial extent from the resource
          extractSpatialExtentFromResource(resourceUrl, format);
        } else {
          console.debug('No resource URL found for spatial processing');
        }
      }
    };
    
    formatField.addEventListener('change', formatField._spatialListener);
    
    // Also check immediately if format is already SHP
    if (formatField.value && formatField.value.toLowerCase() === 'shp') {
      formatField._spatialListener({ target: formatField });
    }
  }

  // Function to show spatial extent extraction messages
  function showSpatialExtentMessage(message, type) {
    // Find or create a message container near the spatial extent field
    var spatialExtentField = document.querySelector('textarea[name="spatial_extent"], input[name="spatial_extent"]');
    if (!spatialExtentField) return;

    var messageContainer = spatialExtentField.parentNode.querySelector('.spatial-extent-message');
    if (!messageContainer) {
      messageContainer = document.createElement('div');
      messageContainer.className = 'spatial-extent-message';
      spatialExtentField.parentNode.appendChild(messageContainer);
    }

    // Set message content and style
    messageContainer.innerHTML = '<i class="fa fa-info-circle"></i> ' + message;
    messageContainer.className = 'spatial-extent-message alert alert-' + 
      (type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'info');

    // Auto-hide after 5 seconds for non-error messages
    if (type !== 'warning') {
      setTimeout(function() {
        if (messageContainer && messageContainer.parentNode) {
          messageContainer.style.opacity = '0';
          setTimeout(function() {
            if (messageContainer && messageContainer.parentNode) {
              messageContainer.parentNode.removeChild(messageContainer);
            }
          }, 300);
        }
      }, 5000);
    }
  }
  // Initialize spatial processing on page load
  document.addEventListener('DOMContentLoaded', function() {
    console.log('Setting up spatial extent processing...');
    
    // Setup format field listener for spatial processing
    var formatField = document.querySelector('select[name*="format"], input[name*="format"]');
    if (formatField) {
      console.log('Found format field, setting up spatial processing listener');
      setupSpatialProcessingOnFormatChange(formatField);
    } else {
      console.debug('No format field found');
    }
    
    // Also watch for dynamically added format fields (for resource forms that may be loaded via AJAX)
    var observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        mutation.addedNodes.forEach(function(node) {
          if (node.nodeType === 1) { // Element node
            var formatField = node.querySelector ? node.querySelector('select[name*="format"], input[name*="format"]') : null;
            if (formatField) {
              console.log('Found new format field, setting up spatial processing listener');
              setupSpatialProcessingOnFormatChange(formatField);
            }
          }
        });
      });
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  });

})();
</script>

<style>
.schemingdcat-upload-wrapper {
  margin-bottom: 20px;
}

.schemingdcat-upload-wrapper .upload-section {
  margin-bottom: 25px;
}

.schemingdcat-upload-wrapper .upload-dropzone {
  border: 3px dashed #c8d6e5;
  border-radius: 12px;
  padding: 40px;
  text-align: center;
  background: linear-gradient(135deg, #f8f9fa 25%, transparent 25%) -50px 0,
              linear-gradient(225deg, #f8f9fa 25%, transparent 25%) -50px 0,
              linear-gradient(315deg, #f8f9fa 25%, transparent 25%),
              linear-gradient(45deg, #f8f9fa 25%, transparent 25%);
  background-size: 100px 100px;
  background-color: #fafbfc;
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  min-height: 220px;
  margin-top: 10px;
  overflow: hidden;
}

.schemingdcat-upload-wrapper .upload-dropzone::before {
  content: '';
  position: absolute;
  top: -2px;
  left: -2px;
  right: -2px;
  bottom: -2px;
  background: linear-gradient(45deg, #2572B4, #4a90e2, #2572B4);
  border-radius: 12px;
  opacity: 0;
  z-index: -1;
  transition: opacity 0.4s ease;
}

.schemingdcat-upload-wrapper .upload-dropzone:hover {
  border-color: #a0b3c7;
  background-color: #f5f7fa;
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}

.schemingdcat-upload-wrapper .upload-dropzone.dragover {
  border-color: #2572B4;
  background-color: #e8f2ff;
  border-style: solid;
  transform: scale(1.02);
  box-shadow: 0 8px 25px rgba(37, 114, 180, 0.25);
}

.schemingdcat-upload-wrapper .upload-dropzone.dragover::before {
  opacity: 0.1;
}

.schemingdcat-upload-wrapper .dropzone-icon {
  position: relative;
  margin-bottom: 20px;
}

.schemingdcat-upload-wrapper .dropzone-icon i {
  font-size: 60px;
  color: #7f8c9b;
  transition: all 0.3s ease;
}

.schemingdcat-upload-wrapper .upload-dropzone:hover .dropzone-icon i,
.schemingdcat-upload-wrapper .upload-dropzone.dragover .dropzone-icon i {
  color: #2572B4;
  transform: translateY(-5px);
}

.schemingdcat-upload-wrapper .dropzone-content h4 {
  color: #495057;
  margin: 15px 0 10px;
  font-size: 20px;
  font-weight: 500;
}

.schemingdcat-upload-wrapper .drop-hint {
  color: #6c757d;
  margin: 10px 0;
  font-size: 14px;
}

.schemingdcat-upload-wrapper .browse-button {
  margin: 15px 0;
  cursor: pointer;
  background: #2572B4;
  border: none;
  padding: 10px 24px;
  font-weight: 500;
  transition: all 0.3s ease;
  box-shadow: 0 2px 5px rgba(37, 114, 180, 0.3);
}

.schemingdcat-upload-wrapper .browse-button:hover {
  background: #1e5a90;
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(37, 114, 180, 0.4);
}

.schemingdcat-upload-wrapper .file-preview {
  text-align: left;
}

.schemingdcat-upload-wrapper .file-info {
  display: flex;
  align-items: center;
  padding: 15px;
  background: #f0f7ff;
  border-radius: 6px;
  gap: 15px;
}

.schemingdcat-upload-wrapper .file-icon {
  color: #2572B4;
}

.schemingdcat-upload-wrapper .file-details {
  flex: 1;
}

.schemingdcat-upload-wrapper .file-details p {
  margin: 0 0 5px 0;
}

.schemingdcat-upload-wrapper .file-name {
  font-weight: bold;
  word-break: break-all;
}

.schemingdcat-upload-wrapper .remove-file {
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.schemingdcat-upload-wrapper .remove-file:hover {
  background-color: #c82333;
  border-color: #bd2130;
  transform: scale(1.05);
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.schemingdcat-upload-wrapper .remove-file i {
  margin-right: 4px;
}

.schemingdcat-upload-wrapper .current-file-info {
  margin-bottom: 20px;
}

/* Upload progress styles */
.schemingdcat-upload-wrapper .upload-progress {
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #e9ecef;
}

.schemingdcat-upload-wrapper .progress-bar {
  width: 100%;
  height: 8px;
  background: #e9ecef;
  border-radius: 4px;
  overflow: hidden;
  position: relative;
}

.schemingdcat-upload-wrapper .progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #2572B4 0%, #4a90e2 50%, #2572B4 100%);
  background-size: 200% 100%;
  border-radius: 4px;
  animation: progressAnimation 2s ease-in-out infinite, shimmer 1.5s linear infinite;
  width: 0%;
}

@keyframes progressAnimation {
  0% { width: 0%; }
  50% { width: 100%; }
  100% { width: 100%; }
}

@keyframes shimmer {
  0% { background-position: -200% center; }
  100% { background-position: 200% center; }
}

.schemingdcat-upload-wrapper .progress-text {
  text-align: center;
  margin-top: 10px;
  color: #6c757d;
  font-size: 14px;
  font-style: italic;
}

.schemingdcat-upload-wrapper .url-or-separator {
  text-align: center;
  margin: 20px 0;
  position: relative;
}

.schemingdcat-upload-wrapper .url-or-separator span {
  background: white;
  padding: 0 15px;
  color: #999;
  font-weight: bold;
  position: relative;
  z-index: 1;
}

.schemingdcat-upload-wrapper .url-or-separator:before {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  height: 1px;
  background: #ddd;
}

.schemingdcat-upload-wrapper .url-section {
  margin-bottom: 15px;
}

.schemingdcat-upload-wrapper .url-section .form-control {
  margin-top: 10px;
}

/* Upload cancelled notification */
.upload-cancelled-notification {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(40, 167, 69, 0.9);
  color: white;
  padding: 12px 24px;
  border-radius: 6px;
  font-weight: 500;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  z-index: 10;
  animation: fadeInOut 2s ease-in-out;
}

.upload-cancelled-notification i {
  margin-right: 8px;
}

@keyframes fadeInOut {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
  20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
  80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
  100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
}

/* Spatial extent loading and message styles */
.spatial-extent-message {
  margin-top: 10px;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 13px;
  transition: opacity 0.3s ease;
}

.spatial-extent-message .fa {
  margin-right: 6px;
}

textarea.loading, input.loading {
  background-image: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
  background-size: 200% 100%;
  animation: shimmerSpatial 1.5s infinite;
}

@keyframes shimmerSpatial {
  0% { background-position: -200% center; }
  100% { background-position: 200% center; }
}

@media (max-width: 768px) {
  .schemingdcat-upload-wrapper .upload-dropzone {
    padding: 20px;
  }
  
  .schemingdcat-upload-wrapper .dropzone-content h4 {
    font-size: 16px;
  }
}
</style>